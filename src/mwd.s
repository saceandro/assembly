	.align 2
	.globl mwd
mwd:				# 表示する整数が、r3に入った状態で呼ばれる。
	li 6, 10		# 整数を、10進数表示の文字列に変換するためには、10で割ったり掛けたりする必要があるので、r6に準備しておく。
	mr 4, 1			# SPを、r4にコピー。r4は、そのまま出力文字列へのポインタとなる。
	li 10, 0
	stbu 10, -1(4)		# ヌル文字を、SP-1のメモリに格納し、r4 <- r4-1 とする。
	cmpi 1, 1, 3, 0		# r3と0を比較した結果を、CR1に格納する。
	bge 1, .loop		# r3 >= 0 ならば、.loopへ分岐
	neg 3, 3		# r3 < 0 ならば、r3を正負反転する。(2の補数表現であるため、r3をビット反転して、1加える。)
.loop:
	divw. 8, 3, 6		# r8 <- r3 / 10 (r8を、r3を10で割った商)とし、r8の比較結果をCR0に格納する。
	mulld 9, 8, 6		# r9 <- r8 / 10 (r9を、r3の一の位を0にした整数とする)
	sub 10, 3, 9		# r10 <- r3 - r9 (r3の一の位の数を求める)
	addi 10, 10, 48		# r3の一の位の数を、ASCIIコードの文字に変換するため、48を加える。
	mr 3, 8			# r3 <- r8 (r3に、元のr3を10で割った商を格納する)
	stbu 10, -1(4)		# r3の一の位の数の文字を、r4-1 のメモリに格納し、r4を1減らす(スタックが成長していく)。
	bne 0, .loop		# r8 (= r3 / 10)の比較結果が、0でなければ、ループ処理。
	bge 1, .last		# 初めに、r3 >= 0であれば、.lastへ分岐する。
	li 10, 45		# 初めにr3 < 0 であれば、'-'を表示する必要があるため、その文字コード45を、r10に格納
	stbu 10, -1(4)		# 45を、r4-1のメモリに格納し、r4を1減らす。
.last:				# システムコール(標準出力)処理
	sub 5, 1, 4		# スタックが伸長した分が、表示する文字数である。
	li 3, 1			# ファイルディスクリプタを、標準出力とする。
	li 0, 4			# r0に、writeのシステムコール番号4を格納する。
	sc			# システムコール命令
	blr
