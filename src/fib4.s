	.align 2
	.globl fib
fib:			  	# r3に引数(n)が入った状態で呼ばれる
	mflr 0			# リンクレジスタ(LR)の内容を、r0に格納する。
	std 0,16(1)		# r0(LRの内容になっている)を、スタックポインタ(SP)+16のメモリに退避する。
	std 14,-16(1)		# SP-16のメモリは、後にfibスタックの不揮発性レジスタ保存領域となるので、不揮発性レジスタr14の値を、その場所に退避しておく。
	stdu 1,-128(1)		# SPの内容を、SP-128のメモリに格納し、更にSPの値を、SP-128で置き換える。これにより、48+64+8+8(アライメントのためのパディング) = 128byteのスタックが確保される。
	mr. 14,3		# 引数が入っているr3は揮発性レジスタなので、これから呼び出す関数で書き換えられても大丈夫なように、先ほど用意したr14にコピーする。更に、cr0にr3の比較結果のフラグが立てられる。
	beq 0,.fin		# r3=0であれば、fib(0)=0であるから、そのまま返せば良いので、復帰処理.finへジャンプする。
	cmpdi 3,1		# r3と1の比較結果を、CR0にセットする。
	beq 0,.fin		# r3=1であれば、fib(1)=1であるから、そのまま返せば良いので、復帰処理.finへジャンプする。
	subi 3,14,1		# n-1を、fibに渡す(再帰)。
	bl fib			# r3にfib(n-1)が入った状態で戻ってくる。
	nop
	subi 4,14,2		# n-2を、一旦r4に格納。
	mr 14,3			# fib(n-1)を、r14に保存。
	mr 3,4			# n-2をfibに渡す(再帰)。
	bl fib			# r3にfib(n-2)が入った状態で戻ってくる。
	nop
	add 3,14,3		# r3には、fib(n-2)、r14にはfib(n-1)が入っているので、fib(n-1) + fib(n-2)を返り値としてr3に格納。
.fin:
	addi 1,1,128		# SPの値を、128だけ増やす(元のアドレスに戻す)。
	ld 0,16(1)		# SP+16のアドレスにあるメモリの内容(64bit)を、r0にロードする。そこには、関数先頭で退避しておいたLRの値が入っている。
	mtlr 0			# LRを、r0で置き換える。つまり、LRを元の内容に復帰する。ここでLRを復帰しておかないと、呼びだし元に戻れない。
	ld 14,-16(1)		# SP-16(関数の初めの方で、r14を退避しておいた場所)のメモリの内容を、r14に格納する。つまり、不揮発性レジスタの復帰処理。
	blr			# 呼び出し元に分岐
